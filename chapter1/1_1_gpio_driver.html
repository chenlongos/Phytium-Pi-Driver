<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GPIO驱动开发 - 飞腾派驱动开发实验指导书</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">飞腾派驱动开发实验指导书</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="11-gpio驱动开发"><a class="header" href="#11-gpio驱动开发">1.1 GPIO驱动开发</a></h1>
<h2 id="1-硬件工作原理"><a class="header" href="#1-硬件工作原理">1. 硬件工作原理</a></h2>
<h3 id="11-模块概述"><a class="header" href="#11-模块概述">1.1 模块概述</a></h3>
<ul>
<li><strong>功能描述</strong></li>
</ul>
<p><em>GPIO</em> 是 <em>General Purpose Input Output（通用输入/输出）</em> 的缩写，也就意味着这种类型的外设可以配置为多种输入/输出类型。单根GPIO的模型可以简单理解为一根导线。
导线的一端留给硬件工程师，他们可以将这一端任意的连接到他们想要的地方，然后告诉驱动工程师，他们想要 ”这根线“ 起到什么作用；导线的一端连接到cpu核心，驱动工程师通过cpu配置这个模块为指定的功能。</p>
<p><a href="https://zh.wikipedia.org/zh-hk/GPIO">一般来说</a>，GPIO可以用于获取某个的高低电平，作为cpu中断触发源等等。</p>
<ul>
<li>
<p><strong>应用场景</strong></p>
<ul>
<li>外部中断源输出。连接到特定的开关上去，当这个开关被按下时，电压发生跳变，由此执行相应逻辑。</li>
<li>检测外部输入，用于检查系统关键位置是否满足要求。</li>
<li>输出恒定电压，用于点亮LED等。</li>
</ul>
</li>
<li>
<p><strong>核心特性</strong></p>
<ul>
<li>开漏输出：可以实现电平转换，输出电平取决于上拉电阻电源；可以实现io的线与逻辑。</li>
<li>推挽输出：通过控制两个晶体管的开关来控制电平状态，优点是驱动能力较强，输出IO口驱动电流最大可到20ma。</li>
<li>浮空输入：浮空输入是指将输入引脚未连接到任何外部信号源或电路，使其处于未定义的状态。</li>
<li>下拉输入：芯片输入引脚通过电阻接到电源电压。</li>
<li>上拉输入：芯片输入引脚通过电阻借到参考0电平。</li>
</ul>
</li>
</ul>
<h3 id="12-硬件接口介绍"><a class="header" href="#12-硬件接口介绍">1.2 硬件接口介绍</a></h3>
<ul>
<li><strong>扩展头</strong>：飞腾派（Phytium Pi）开发板提供 40-pin GPIO 扩展头（双排引脚，间距 2.54mm），位于板边，兼容类树莓派布局。引脚涵盖通用 GPIO、电源、GND 和专用信号（如 I2C、UART）。</li>
<li><strong>引脚数量</strong>：最多暴露 29 个通用 GPIO（来自 6 个控制器，总 96 个信号，受板上限制）。其他引脚支持多路复用（MUX）为 I2C、SPI、UART、CAN 等。</li>
<li><strong>电平标准</strong>：3.3V TTL 逻辑电平（高电平 &gt;2V，低电平 &lt;0.8V）。每个引脚最大电流约 16mA，总电流限制 50-100mA（依版本）。</li>
<li><strong>颜色区分</strong>：
<ul>
<li>电源：红（3.3V/5V，Pin 1/2 等）。</li>
<li>GND：黑（Pin 6/9 等）。</li>
<li>GPIO：橙（e.g., Pin 7: GPIO2_10）。</li>
<li>专用信号：绿（e.g., Pin 3/5: I2C1_SDA/SCL）。</li>
</ul>
</li>
</ul>
<p>示例引脚（部分）：</p>
<ul>
<li>Pin 7: GPIO2_10（MUX 为 UART2_TXD、DP1_HPD 等）。</li>
<li>Pin 11: GPIO3_1（MUX 为 UART2_CTS_N、SPIM2_CSN2）。</li>
<li>Pin 3/5: I2C1_SDA/SCL（MUX 为 CAN1_RX/TX）。</li>
</ul>
<p><img src="./../resource/img/1_1_PhytiumPiGPIO.png" alt="1_1_PhytiumPiGPIO" /></p>
<h3 id="13-时序图"><a class="header" href="#13-时序图">1.3 时序图</a></h3>
<p>飞腾派（Phytium Pi）GPIO 设备支持异步数字输入/输出和中断触发，无固定时钟信号。以下为 GPIO 的典型时序图，展示输出控制（如 LED 点亮/熄灭）和中断触发（如按钮按下检测）。时序图基于 3.3V 电平，切换时间 &lt;10ns，支持上升/下降沿中断。</p>
<p><strong>GPIO 输出时序（LED 控制示例）</strong></p>
<p>描述：驱动程序通过寄存器（如 GPIO 输出寄存器）设置引脚电平（高/低），控制外部 LED。假设使用 Pin 7（GPIO2_10）点亮/熄灭 LED。</p>
<pre class="mermaid">sequenceDiagram
    participant D as 驱动
    participant G as GPIO控制器
    participant L as LED
    D-&gt;&gt;G: 写寄存器（0x28034000，设高电平）
    G-&gt;&gt;L: 输出 3.3V（点亮）
    Note over G,L: 切换时间 &lt;10ns
    D-&gt;&gt;G: 写寄存器（设低电平）
    G-&gt;&gt;L: 输出 0V（熄灭）
</pre>
<p><strong>GPIO 中断时序（按钮触发示例）</strong></p>
<p>描述：配置 GPIO 为输入模式，启用中断（上升沿触发），检测按钮按下。假设使用 Pin 11（GPIO3_1）连接按钮。</p>
<pre class="mermaid">sequenceDiagram
    participant B as 按钮
    participant G as GPIO控制器
    participant D as 驱动
    B-&gt;&gt;G: 按钮按下（电平 0V-&gt;3.3V）
    G-&gt;&gt;D: 触发中断（GIC_SPI，上升沿）
    Note over G,D: 响应时间 &lt;10ns
    D-&gt;&gt;G: 读取状态寄存器，处理事件
    D-&gt;&gt;G: 清除中断（IC_CLR_INTR）
</pre>
<h3 id="说明"><a class="header" href="#说明">说明</a></h3>
<ul>
<li><strong>输出时序</strong>：GPIO 无固定时钟，驱动通过寄存器直接控制电平。LED 响应为瞬时（&lt;10ns），需串联 330Ω 电阻防止过流。</li>
<li><strong>中断时序</strong>：中断通过 GIC（Generic Interrupt Controller）处理，需配置 PAD 寄存器（0x32B30000）启用上下拉和中断模式。</li>
<li><strong>异常情况</strong>：电平不稳定可能导致中断误触发，建议检查上下拉配置（x_reg0 寄存器）。</li>
</ul>
<h2 id="2接口表"><a class="header" href="#2接口表">2.接口表</a></h2>
<h3 id="pl061-接口表"><a class="header" href="#pl061-接口表">pl061 接口表</a></h3>
<ul>
<li><strong>表格格式</strong>：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>API函数</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody>
<tr><td>Pl0611::new</td><td>创建gpio实例</td><td>base_addr: Gpio控制器的基地址</td><td>初始化的gpio控制器</td></tr>
<tr><td>Pl0611::set_func</td><td>设置gpio引脚功能</td><td>self,ch:通道号,func: Gpio功能</td><td>Result&lt;(),IoError&gt;,成功Ok(()), 失败：无效的通道号</td></tr>
<tr><td>Pl0611::int_when</td><td>设置gpio中断条件</td><td>self, ch:通道号,cond:什么时候触发中断，必须先配置为中断模式</td><td>Result&lt;(),IoError&gt; 成功Ok(()), 失败：无效的通道号</td></tr>
<tr><td>Pl0611::set_output</td><td>设置gpio输出值</td><td>self, ch:通道号, val:引脚值</td><td>Result&lt;(),IoError&gt; 成功Ok(()), 失败：无效的通道号(没有配置为输出)</td></tr>
<tr><td>Pl0611::get_input</td><td>设置gpio输出值</td><td>self, ch:通道号,</td><td>Result&lt;bool,IoError&gt; 成功Ok(value), 失败：无效的通道号</td></tr>
</tbody></table>
</div>
<h3 id="飞腾派-gpio1-接口表"><a class="header" href="#飞腾派-gpio1-接口表">飞腾派 GPIO1 接口表</a></h3>
<ul>
<li><strong>表格格式</strong>：</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>API函数</th><th>描述</th><th>参数</th><th>返回值</th></tr></thead><tbody>
<tr><td>PhytiumGpio::new</td><td>创建gpio实例</td><td>base_addr: Gpio控制器的基地址</td><td>初始化的gpio控制器</td></tr>
<tr><td>PhytiumGpio::set_func</td><td>设置gpio引脚功能</td><td>self,ch:通道号,func: Gpio功能</td><td>Result&lt;(),IoError&gt;,成功Ok(()), 失败：无效的通道号</td></tr>
<tr><td>PhytiumGpio::set_output</td><td>设置gpio输出值</td><td>self, ch:通道号, val:引脚值</td><td>Result&lt;(),IoError&gt; 成功Ok(()), 失败：无效的通道号(没有配置为输出)</td></tr>
<tr><td>PhytiumGpio::get_input</td><td>设置gpio输出值</td><td>self, ch:通道号,</td><td>Result&lt;bool,IoError&gt; 成功Ok(value), 失败：无效的通道号</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p><strong>调用顺序</strong></p>
<ul>
<li>中断模式
<ul>
<li>初始化</li>
<li>配置中断模式</li>
<li>配置中断条件</li>
<li>定义自己的中断函数并注册</li>
</ul>
</li>
<li>输入/输出模式
<ul>
<li>初始化</li>
<li>配置输入/输出功能</li>
<li>输入/输出值</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>错误处理</strong>
IoError::InvChn 不合法的通道</p>
</li>
</ul>
<h2 id="3-寄存器结构"><a class="header" href="#3-寄存器结构">3. 寄存器结构</a></h2>
<h3 id="pl061模块"><a class="header" href="#pl061模块">pl061模块</a></h3>
<ul>
<li>
<p><strong>基地址</strong>
对于嵌入式平台，device tree是一种常用的方法。这次实现也需要通过设备树的方法获取基地址。不幸的是 qemu 没有直接提供他的设备树，但是启动的时候确实会传递一个默认的设备树。我们通过<a href="#%E5%AF%BC%E5%87%BAqemu%E8%AE%BE%E5%A4%87%E6%A0%91">导出qemu设备树</a>的方法来获取设备树。获得了dts之后，我们在这个dts中搜索 "pl061",可以看到这个：</p>
<p><img src="../resource/img/1_1_qemu_device_tree.png" alt="设备树" /></p>
<p>pl061@9030000说明基地址为 0x9030000。</p>
</li>
<li>
<p><strong>寄存器表</strong></p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>寄存器名称</th><th>偏移</th><th>寄存器定义</th></tr></thead><tbody>
<tr><td>GPIODIR</td><td>0x400</td><td>设置GPIO引脚的输入输出功能，1代表该引脚为输出模式，0代表该引脚为输入模式。</td></tr>
<tr><td>GPIOIS</td><td>0x404</td><td>中断的触发方式p1，0代表检测电压，1代表检测边缘</td></tr>
<tr><td>GPIOIBE</td><td>0x408</td><td>中断的触发方式p2，0代表中断通过GPIOIEV来控制，1代表上升沿和下降沿都能触发中断</td></tr>
<tr><td>GPIOIEV</td><td>0x40c</td><td>中断的触发方式设置p3，如果中断设置为边沿触发，0代表设置为下降沿触发，1代表上升沿触发；如果中断设置为电平触发， 0代表低电平，1代表高电平</td></tr>
<tr><td>GPIOIE</td><td>0x410</td><td>1是使能中断，0是去使能中断</td></tr>
</tbody></table>
</div>
<h3 id="飞腾派gpio1模块"><a class="header" href="#飞腾派gpio1模块">飞腾派GPIO1模块</a></h3>
<ul>
<li>
<p><strong>基地址</strong>
通过数据手册可以查出，GPIO1模块的基地址为0x000_2803_5000。</p>
</li>
<li>
<p><strong>寄存器表</strong></p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>寄存器名称</th><th>偏移</th><th>寄存器定义</th></tr></thead><tbody>
<tr><td>GPIO_SWPORT_DR</td><td>0x00</td><td>每一bit定义了对应引脚的输出值(当配置为输出模式时)。如果该引脚被配置为输出模式，写入这个寄存器的值将会被输出。1对应高电平，0对应低电平。</td></tr>
<tr><td>GPIO_SWPORT_DDR</td><td>0x04</td><td>每一bit定义了对应引脚的in/out属性。1代表该引脚为输出模式，0代表该引脚为输入模式。</td></tr>
<tr><td>GPIO_EXT_PORT</td><td>0x08</td><td>每一bit定义了对应引脚的引脚值。1代表对应引脚输出为高，0代表输出为低。</td></tr>
</tbody></table>
</div>
<h2 id="4-具体实现讲解"><a class="header" href="#4-具体实现讲解">4 具体实现讲解</a></h2>
<h3 id="qemu平台关机实验"><a class="header" href="#qemu平台关机实验">qemu平台关机实验</a></h3>
<p><em>对于一些简单的设备，qemu能够很好的进行模拟。因此，对于部分没有开发板而想尝试进行驱动开发学习的同学，我们提供了基于qemu的部分实验。</em></p>
<ul>
<li>
<p>在arceos代码仓库下，使用example为helloworld，先尝试运行得到以下结果。</p>
<details>
  <summary>运行结果</summary>
      arceos git:(main)✗ make A=examples/helloworld PLATFORM=aarch64-qemu-virt ARCH=aarch64  LOG=debug FEATURES="driver-ramdisk,irq" run ACCEL=n GRAPHIC=n
<pre><code>  ... # skip part build log
  axconfig-gen configs/defconfig.toml configs/platforms/aarch64-qemu-virt.toml  -w smp=1 -w arch=aarch64 -w platform=aarch64-qemu-virt -o "/Users/jp/code/arceos/.axconfig.toml" -c "/Users/jp/code/arceos/.axconfig.toml"
  Building App: helloworld, Arch: aarch64, Platform: aarch64-qemu-virt, App type: rust
  cargo -C examples/helloworld build -Z unstable-options --target aarch64-unknown-none-softfloat --target-dir /Users/jp/code/arceos/target --release  --features "axstd/log-level-debug axstd/driver-ramdisk axstd/irq"
  Finished `release` profile [optimized] target(s) in 0.08s
  rust-objcopy --binary-architecture=aarch64 examples/helloworld/helloworld_aarch64-qemu-virt.elf --strip-all -O binary examples/helloworld/helloworld_aarch64-qemu-virt.bin
  Running on qemu...
  qemu-system-aarch64 -m 128M -smp 1 -cpu cortex-a72 -machine virt -kernel examples/helloworld/helloworld_aarch64-qemu-virt.bin -nographic

      d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
      d88P888                           888     888 Y88b.
  d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
  d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
  d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
  d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

  arch = aarch64
  platform = aarch64-qemu-virt
  target = aarch64-unknown-none-softfloat
  build_mode = release
  log_level = debug
  smp = 1

  [  0.001902 0 axruntime:130] Logging is enabled.
  [  0.002488 0 axruntime:131] Primary CPU 0 started, dtb = 0x44000000.
  [  0.002738 0 axruntime:133] Found physcial memory regions:
  [  0.002968 0 axruntime:135]   [PA:0x40200000, PA:0x40206000) .text (READ | EXECUTE | RESERVED)
  [  0.003304 0 axruntime:135]   [PA:0x40206000, PA:0x40209000) .rodata (READ | RESERVED)
  [  0.003502 0 axruntime:135]   [PA:0x40209000, PA:0x4020d000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
  [  0.003714 0 axruntime:135]   [PA:0x4020d000, PA:0x4024d000) boot stack (READ | WRITE | RESERVED)
  [  0.003892 0 axruntime:135]   [PA:0x4024d000, PA:0x40250000) .bss (READ | WRITE | RESERVED)
  [  0.004080 0 axruntime:135]   [PA:0x40250000, PA:0x48000000) free memory (READ | WRITE | FREE)
  [  0.004290 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.004482 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.004662 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.004806 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.004948 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.005098 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
  [  0.005284 0 axruntime:150] Initialize platform devices...
  [  0.005420 0 axhal::platform::aarch64_common::gic:51] Initialize GICv2...
  [  0.006258 0 axruntime:176] Initialize interrupt handlers...
  [  0.006466 0 axhal::irq:32] irq=30 enabled
  [  0.006830 0 axruntime:188] Primary CPU 0 init OK.
  Hello, world!
  [  0.007086 0 axruntime:201] main task exited: exit_code=0
  [  0.007248 0 axhal::platform::aarch64_common::psci:98] Shutting down...
</code></pre>
</details>
</li>
<li>
<p>由于目前arceos是unikernel模式，特权级为el1，所以可以直接在 <em>main.c</em> 中操作设备地址（<strong>需要注意的是，这不是一种正确的做法。但对于初学者，为了不在一开始就去研究arecos的复杂代码框架，可以短暂的把实现代码写在这儿。</strong>），将pl061模块的三号引脚配置为irq模式。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// examples/helloworld/main.c
...
/// 0x9030000 是 qemu模拟的aarch64-qemu-virt机器的 pl061模块的基地址(物理地址)。
<span class="boring">/// irq number 39 从 aarch64-qemu-virt机器的设备树中找到，7 + 外部中断base(32) = 39
</span>unsafe fn set_gpio_irq_enable() {
    // PHYS_VIRT_OFFSET 是 arceos 初始化时，将物理内存映射时进行的偏移。
    let base_addr = (0x9030000 + PHYS_VIRT_OFFSET) as *mut u8;
    // pl061的3号引脚
    let pin = 3;
    // 将interrupt设置为边缘触发
    let gpio_is = base_addr.add(0x404);
    *gpio_is = *gpio_is &amp; !(1 &lt;&lt; pin);
    // 设置触发事件
    let gpio_iev = base_addr.add(0x40c);
    *gpio_iev = *gpio_iev &amp; !(1 &lt;&lt; pin);
    
    // 设置中断使能
    let gpio_ie = base_addr.add(0x410);
    *gpio_ie = 0;
    *gpio_ie = *gpio_ie | (1 &lt;&lt; pin);

<span class="boring">    fn shut_down() {
</span><span class="boring">       println!("shutdown function called");
</span><span class="boring">       unsafe {
</span><span class="boring">           let base_addr = (0x9030000 + PHYS_VIRT_OFFSET) as *mut u8;
</span><span class="boring">           let pin = 3;
</span><span class="boring">           // clear interrupt
</span><span class="boring">           let gpio_ic = base_addr.add(0x41c);
</span><span class="boring">           *gpio_ic = (1 &lt;&lt; pin);
</span><span class="boring">           // 关机命令
</span><span class="boring">           core::arch::asm!(
</span><span class="boring">               "mov w0, #0x18;
</span><span class="boring">               hlt #0xf000"
</span><span class="boring">           )
</span><span class="boring">       }
</span><span class="boring">    };
</span><span class="boring">    register_handler(39, shut_down);
</span><span class="boring">    println!("set irq done");
</span>}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>并将中断号注册到 <a href="https://developer.arm.com/Architectures/Generic%20Interrupt%20Controller"><em>GIC(generic interrupt controller)</em></a>中，中断号是39。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// examples/helloworld/main.c
...
<span class="boring">/// 0x9030000 是 qemu模拟的aarch64-qemu-virt机器的 pl061模块的基地址(物理地址)。
</span>/// irq number 39 从 aarch64-qemu-virt机器的设备树中找到，7 + 外部中断base(32) = 39
<span class="boring">unsafe fn set_gpio_irq_enable() {
</span><span class="boring">   // PHYS_VIRT_OFFSET 是 arceos 初始化时，将物理内存映射时进行的偏移。
</span><span class="boring">let base_addr = (0x9030000 + PHYS_VIRT_OFFSET) as *mut u8;
</span><span class="boring">// pl061的3号引脚
</span><span class="boring">let pin = 3;
</span><span class="boring">// 将interrupt设置为边缘触发
</span><span class="boring">let gpio_is = base_addr.add(0x404);
</span><span class="boring">*gpio_is = *gpio_is &amp; !(1 &lt;&lt; pin);
</span><span class="boring">// 设置触发事件
</span><span class="boring">let gpio_iev = base_addr.add(0x40c);
</span><span class="boring">*gpio_iev = *gpio_iev &amp; !(1 &lt;&lt; pin);
</span><span class="boring">
</span><span class="boring">// 设置中断使能
</span><span class="boring">let gpio_ie = base_addr.add(0x410);
</span><span class="boring">*gpio_ie = 0;
</span><span class="boring">*gpio_ie = *gpio_ie | (1 &lt;&lt; pin);
</span>
    fn shut_down() {
        println!("shutdown function called");
        unsafe {
            let base_addr = (0x9030000 + PHYS_VIRT_OFFSET) as *mut u8;
            let pin = 3;
            // clear interrupt
            let gpio_ic = base_addr.add(0x41c);
            *gpio_ic = (1 &lt;&lt; pin);
            // 关机命令，可以用别的函数替代
            core::arch::asm!(
                "mov w0, #0x18;
                hlt #0xf000"
            )
        }
    };
    // register handler 会同时将注册和在gic中使能中断完成。
    register_handler(39, shut_down);
    println!("set irq done");
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>在main中死循环，等待gpio触发中断。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[cfg_attr(feature = "axstd", unsafe(no_mangle))]
</span><span class="boring">fn main() {
</span>  println!("Hello, world!");
  unsafe {
      set_gpio_irq_enable();
  }
  println!("loop started!");
  loop {
      sleep(time::Duration::from_millis(10));
  }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>重新执行第一步命令，若无报错，输入 <code>ctrl + a + c</code> 进入qemu的console模式，输入<code>system_powerdown</code>时，qemu会模拟一次中断。</p>
<pre><code class="language-shell">...
  [  0.005842 0 axhal::platform::aarch64_common::gic:51] Initialize GICv2...
  [  0.006358 0 axruntime:176] Initialize interrupt handlers...
  [  0.006554 0 axhal::irq:32] irq=30 enabled
  [  0.007232 0 axruntime:188] Primary CPU 0 init OK.
  Hello, world!
  GPIORIS=0x0
  [  0.007688 0 axhal::irq:32] irq=39 enabled
  set irq done
  loop started!
  QEMU 9.2.0 monitor - type 'help' for more information
  (qemu) syst
  system_powerdown  system_reset      system_wakeup     
  (qemu) system_powerdown 
</code></pre>
</li>
<li>
<p><em>GIC</em> 会将中断分发给 arm 某个核心（由于我们是单核，不存在分发）, cpu对我们注册的关机函数进行回调。</p>
<pre><code class="language-shell">  ...
  (qemu) system_powerdown 
  (qemu) shutdown function called
  [ 50.194414 0 axruntime::lang_items:5] panicked at /Users/jp/.cargo/registry/src/mirrors.ustc.edu.cn-38d0e5eb5da2abae/axcpu-0.1.0/src/aarch64/trap.rs:112:13:
  Unhandled synchronous exception @ 0xffff0000402010b0: ESR=0x2000000 (EC 0b000000, ISS 0x0)
  [ 50.195002 0 axhal::platform::aarch64_common::psci:98] Shutting down...
</code></pre>
</li>
</ul>
<h3 id="飞腾派点灯实验"><a class="header" href="#飞腾派点灯实验">飞腾派点灯实验</a></h3>
<p>基本思想是将GPIO配置为作为输出模式，对应的，这个GPIO可以输出为高电平或者低电平。我们都学过初中物理，知道当一个led灯两侧有足够的电压和电流的时候，它就会亮。不过一般的GPIO线输出电流能力都不强，不足以驱动一个led灯。所以一般会用以下两种方式来实现：</p>
<ul>
<li>led正极接电源，负极接gpio。gpio输出为低时，led点亮。</li>
<li>led接 <em><a href="https://baike.baidu.com/item/%E9%87%91%E5%B1%9E%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%9C%BA%E6%95%88%E5%BA%94%E7%AE%A1/8129105">mos</a></em> 管的<em>gate</em>。一般来说，GPIO为高电压时，会使得<em>mos</em>管闭合，led点亮；反之则熄灭。</li>
</ul>
<p>参照飞腾派的硬件原理图，板子上有一个灯可以被我们控制，也就是<em>led20</em>，控制方法为第二种方法，控制GPIO线为GPIO1_8。
<img src="../resource/img/1_1_cpu_run.png" alt="cpu_run" />
<img src="../resource/img/1_1_gpio1_8.png" alt="gpio1_8" /></p>
<p><em>当然，如果你愿意，飞腾派开发板提供了很多GPIO的拓展线。你可以自己实现一套电路来点亮外接的led灯。</em></p>
<p>我们最终要实现led灯的"心跳"效果，即 亮1秒，暗1秒，如此往复循环。</p>
<ul>
<li>编写驱动代码，实现 <em>set_dir</em> 和 <em>set_data</em> 操作，示例代码如下：
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bitflags::bitflags;
use safe_mmio::fields::ReadWrite;
use zerocopy::{FromBytes, Immutable, IntoBytes, KnownLayout};

#[derive(Clone, Eq, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq)]
#[repr(C, align(4))]
pub struct PhitiumGpio {
  data: ReadWrite&lt;GpioPins&gt;,
  resv: ReadWrite&lt;u16&gt;,
  dir: ReadWrite&lt;GpioPins&gt;,
  resv2: ReadWrite&lt;u16&gt;,
}

#[repr(transparent)]
#[derive(Copy, Clone, Debug, Eq, FromBytes, Immutable, IntoBytes, KnownLayout, PartialEq)]
pub struct GpioPins(u16);

bitflags! {
  impl GpioPins: u16 {
      const p0 = 1&lt;&lt;0;
      const p1 = 1&lt;&lt;1;
      const p2 = 1&lt;&lt;2;
      const p3 = 1&lt;&lt;3;
      const p4 = 1&lt;&lt;4;
      const p5 = 1&lt;&lt;5;
      const p6 = 1&lt;&lt;6;
      const p7 = 1&lt;&lt;7;
      const p8 = 1&lt;&lt;8;
      const p9 = 1&lt;&lt;9;
      const p10 = 1&lt;&lt;10;
      const p11 = 1&lt;&lt;11;
      const p12 = 1&lt;&lt;12;
      const p13 = 1&lt;&lt;13;
      const p14 = 1&lt;&lt;14;
      const p15 = 1&lt;&lt;15;
  }
}

impl PhitiumGpio {
  pub fn new(base: usize) -&gt; &amp;'static mut Self {
      let b = base as *mut PhitiumGpio;
      unsafe { &amp;mut (*b) }
  }
  pub fn set_pin_dir(&amp;mut self, pin: GpioPins, dir: bool) {
      let mut status = self.dir.0.bits();
      debug!("dir data = {status}");
      let pb = pin.bits();
      if dir == true {
          status |= pb;
      } else {
          status &amp;= !pb;
      }
      debug!("dir data = {status}");
      self.dir.0 = (GpioPins::from_bits_truncate(status));
  }
  pub fn set_pin_data(&amp;mut self, pin: GpioPins, data: bool) {
      let mut status = self.dir.0.bits();
      debug!(" data = {status}");
      let pb = pin.bits();
      if data == true {
          status |= pb;
      } else {
          status &amp;= !pb;
      }
      debug!(" data = {status}");
      self.data.0 = (GpioPins::from_bits_truncate(status));
  }
}
pub use crate::mem::phys_to_virt;
pub use memory_addr::PhysAddr;

pub const BASE1: PhysAddr = pa!(0x28035000);
<span class="boring">}</span></code></pre></pre>
</li>
<li>由于我们目前暂时没有文件系统，无法通过读写文件的方式来控制GPIO。这里直接在main.rs中实例一个GPIO控制器进行相关初始化。
<pre><pre class="playground"><code class="language-rust">// examples/helloworld/src/main.rs

#![cfg_attr(feature = "axstd", no_std)]
#![cfg_attr(feature = "axstd", no_main)]

<span class="boring">use core::time;
</span>
#[cfg(feature = "axstd")]
use axstd::println;

<span class="boring">use axstd::thread::sleep;
</span>
#[cfg_attr(feature = "axstd", unsafe(no_mangle))]
fn main() {
    println!("Hello, world!");
    let gpio0 = axhal::platform::gpio::PhitiumGpio::new(
        axhal::platform::gpio::phys_to_virt(axhal::platform::gpio::BASE1).into(),
    );
    let p = axhal::platform::gpio::GpioPins::p8;
    gpio0.set_pin_dir(p, true);
<span class="boring">    let mut data = false;
</span><span class="boring">    loop {
</span><span class="boring">       sleep(time::Duration::from_secs(1));
</span><span class="boring">       gpio0.set_pin_data(p, data);
</span><span class="boring">       println!("current data: {data}");
</span><span class="boring">       data = !data;
</span><span class="boring">    }
</span>}
</code></pre></pre>
</li>
<li>创建一个大loop，在这个loop中，我们不停的将pin 8的值进行反转，反转一次，sleep 1s，这样就实现了1s灭，1s亮的效果。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">  // examples/helloworld/src/main.rs

<span class="boring">  #![cfg_attr(feature = "axstd", no_std)]
</span><span class="boring">  #![cfg_attr(feature = "axstd", no_main)]
</span>
  use core::time;

  #[cfg(feature = "axstd")]
  use axstd::println;

  use axstd::thread::sleep;

<span class="boring">  #[cfg_attr(feature = "axstd", unsafe(no_mangle))]
</span><span class="boring">  fn main() {
</span><span class="boring">      println!("Hello, world!");
</span><span class="boring">      let gpio0 = axhal::platform::gpio::PhitiumGpio::new(
</span><span class="boring">         axhal::platform::gpio::phys_to_virt(axhal::platform::gpio::BASE1).into(),
</span><span class="boring">      );
</span><span class="boring">      let p = axhal::platform::gpio::GpioPins::p8;
</span><span class="boring">      gpio0.set_pin_dir(p, true);
</span><span class="boring">      et mut data = false;
</span>      loop {
          sleep(time::Duration::from_secs(1));
          gpio0.set_pin_data(p, data);
          println!("current data: {data}");
          data = !data;
      }
<span class="boring"> } </span></code></pre></pre>
<ul>
<li>通过<code>make A=examples/helloworld ARCH=aarch64 PLATFORM=aarch64-phytium-pi  FEATURES=irq LOG=debug</code>进行编译，并烧入飞腾派运行。下面是运行日志以及实拍。</li>
</ul>
<details>
  <summary>运行结果</summary>
<pre><code>Starting kernel ...


      d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
    d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
  d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-phytium-pi
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = trace
smp = 1

[ 13.461312 0 axruntime:130] Logging is enabled.
[ 13.467040 0 axruntime:131] Primary CPU 0 started, dtb = 0xf9c29000.
[ 13.474591 0 axruntime:133] Found physcial memory regions:
[ 13.481276 0 axruntime:135]   [PA:0x90000000, PA:0x90007000) .text (READ | EXECUTE | RESERVED)
[ 13.491083 0 axruntime:135]   [PA:0x90007000, PA:0x9000a000) .rodata (READ | RESERVED)
[ 13.500197 0 axruntime:135]   [PA:0x9000a000, PA:0x9000e000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[ 13.511655 0 axruntime:135]   [PA:0x9000e000, PA:0x9004e000) boot stack (READ | WRITE | RESERVED)
[ 13.521724 0 axruntime:135]   [PA:0x9004e000, PA:0x90051000) .bss (READ | WRITE | RESERVED)
[ 13.531272 0 axruntime:135]   [PA:0x90051000, PA:0x100000000) free memory (READ | WRITE | FREE)
[ 13.541167 0 axruntime:135]   [PA:0x2800c000, PA:0x2800d000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.551496 0 axruntime:135]   [PA:0x2800d000, PA:0x2800e000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.561825 0 axruntime:135]   [PA:0x2800e000, PA:0x2800f000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.572155 0 axruntime:135]   [PA:0x2800f000, PA:0x28010000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.582484 0 axruntime:135]   [PA:0x30000000, PA:0x38000000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.592813 0 axruntime:135]   [PA:0x40000000, PA:0x50000000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.603142 0 axruntime:135]   [PA:0x58000000, PA:0x80000000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.613471 0 axruntime:135]   [PA:0x28014000, PA:0x28016000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.623800 0 axruntime:135]   [PA:0x28016000, PA:0x28018000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.634130 0 axruntime:135]   [PA:0x28018000, PA:0x2801a000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.644459 0 axruntime:135]   [PA:0x2801a000, PA:0x2801c000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.654788 0 axruntime:135]   [PA:0x2801c000, PA:0x2801e000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.665117 0 axruntime:135]   [PA:0x28034000, PA:0x28035000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.675446 0 axruntime:135]   [PA:0x28035000, PA:0x28036000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.685776 0 axruntime:135]   [PA:0x28036000, PA:0x28037000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.696105 0 axruntime:135]   [PA:0x28037000, PA:0x28038000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.706434 0 axruntime:135]   [PA:0x28038000, PA:0x28039000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.716763 0 axruntime:135]   [PA:0x28039000, PA:0x2803a000) mmio (READ | WRITE | DEVICE | RESERVED)
[ 13.727093 0 axruntime:150] Initialize platform devices...
[ 13.733776 0 axhal::platform::aarch64_common::gic:51] Initialize GICv2...
[ 13.741897 0 axhal::platform::aarch64_common::gic:27] GICD set enable: 30 true
[ 13.750182 0 axhal::platform::aarch64_common::gic:27] GICD set enable: 116 true
[ 13.758688 0 axruntime:176] Initialize interrupt handlers...
[ 13.765545 0 axhal::platform::aarch64_common::gic:36] register handler irq 30
[ 13.773878 0 axhal::platform::aarch64_common::gic:27] GICD set enable: 30 true
[ 13.782298 0 axruntime:188] Primary CPU 0 init OK.
Hello, world!
[ 13.789589 0 axhal::platform::aarch64_phytium_pi::gpio:46] dir data = 0
[ 13.797401 0 axhal::platform::aarch64_phytium_pi::gpio:53] dir data = 256
[ 14.805386 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 14.810239 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
[ 15.819614 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 15.824467 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 256
current data: true
[ 16.833928 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 16.838781 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
[ 17.848156 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 17.853009 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 256
current data: true
[ 18.862470 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 18.867323 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
[ 19.876698 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 19.881551 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 256
current data: true
[ 20.891012 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 20.895865 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
[ 21.905240 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 21.910093 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 256
current data: true
[ 22.919554 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 22.924407 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
[ 23.933782 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 23.938635 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 256
current data: true
[ 24.948097 0 axhal::platform::aarch64_phytium_pi::gpio:58]  data = 256
[ 24.952950 0 axhal::platform::aarch64_phytium_pi::gpio:65]  data = 0
current data: false
</code></pre>
</details>
<p><img src="../resource/img/1_1_led_on.jpg" alt="led亮" /></p>
<p><img src="../resource/img/1_1_led_off.jpg" alt="led_off" /></p>
<h2 id="5-开发注意"><a class="header" href="#5-开发注意">5. 开发注意</a></h2>
<h3 id="51-优化代码"><a class="header" href="#51-优化代码">5.1 优化代码</a></h3>
<ul>
<li>目前驱动代码位于 <code>examples/helloworld/main.c</code> 中，这不是一种正确的做法。参考 <code>modules/axhal/src/platform/aarch64_common/pl011.rs</code> 的实现，在同级目录下实现 pl061.rs。 rust 提供了如 <code>tock_registers</code> 这样的可以用来定义寄存器的crate，用起来！</li>
<li>关机函数实际上是触发了一个异常而导致的关机，当把上一步完成后，换成 <code>axhal::misc::terminate</code> 来优雅的关机！</li>
<li>实验2的完整代码在<a href="https://github.com/arceos-org/arceos/commit/2e7837a786d13b0a77804d15a10f614ef715150d">https://github.com/arceos-org/arceos/commit/2e7837a786d13b0a77804d15a10f614ef715150d</a>。</li>
</ul>
<h2 id="6-参考资料"><a class="header" href="#6-参考资料">6. 参考资料</a></h2>
<h3 id="pl061_datasheet"><a class="header" href="#pl061_datasheet">pl061_datasheet:</a></h3>
<p><a href="https://github.com/elliott10/dev-hw-driver/blob/main/docs/GPIO-controller-pl061-DDI0190.pdf">https://github.com/elliott10/dev-hw-driver/blob/main/docs/GPIO-controller-pl061-DDI0190.pdf</a></p>
<h3 id="导出qemu设备树"><a class="header" href="#导出qemu设备树">导出qemu设备树:</a></h3>
<p><a href="https://blog.51cto.com/u_15072780/3818667">https://blog.51cto.com/u_15072780/3818667</a></p>
<h3 id="飞腾派硬件原理图"><a class="header" href="#飞腾派硬件原理图">飞腾派硬件原理图:</a></h3>
<p><a href="https://github.com/elliott10/dev-hw-driver/blob/main/phytiumpi/docs/%E9%A3%9E%E8%85%BE%E6%B4%BEv3%E5%8E%9F%E7%90%86%E5%9B%BE%20cek8903_piq_v3_sch20240506.pdf">https://github.com/elliott10/dev-hw-driver/blob/main/phytiumpi/docs/%E9%A3%9E%E8%85%BE%E6%B4%BEv3%E5%8E%9F%E7%90%86%E5%9B%BE%20cek8903_piq_v3_sch20240506.pdf</a></p>
<h3 id="飞腾派软件开发手册"><a class="header" href="#飞腾派软件开发手册">飞腾派软件开发手册</a></h3>
<p><a href="https://github.com/elliott10/dev-hw-driver/blob/main/phytiumpi/docs/%E9%A3%9E%E8%85%BE%E6%B4%BE%E8%BD%AF%E4%BB%B6%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8CV1.0.pdf">https://github.com/elliott10/dev-hw-driver/blob/main/phytiumpi/docs/飞腾派软件编程手册V1.0.pdf</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter1/chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter1/1_2_pwm_driver.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter1/chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter1/1_2_pwm_driver.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>
